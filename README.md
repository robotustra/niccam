[29.05.2017]

#README

Генерация G-code из STL модели для 3D ферзерования.

Необходимо строить задачу иерархически, например на самом верхнем уровне будет
Работа, или цикл
Цикл - это последовательность операций над заготовкой, которую следует выполнить чтобы получить требуемую обработку.

* Цикл состоит из проходов, пауз или смен оборудования, и установок координат.

--

	0) Установка начала координат, это скрипт, который выполняется при установленном пробнике и задает 
начала отсчета для следующей операции.

	1) Проход - это последовательность движений фрезы одного типа без перестановки.

	2) Пауза или смена оборудования - это фрагмент кода, при котором определяется оператором следующее действие.


Для генерации прохода необходимо задать 
	
	1) Модель, или 3D файл, в формате STL.
	2) Ориентацию модели в пространстве, по отношению к системе координат станка.
	3) Инструмент для прохода, его геометрию.

	4) Карман выборки. Это призматический объем, который определяет место выборки, в предельном случае совпадает 
	с геометрией заготовки.

	5) Параметры фрезерования


---

[30.05.2017]

	Видимо придется делать свой кад с нуля, так как опенскад меня не очень устраивает.

Техническое задание:
textcad должен
1) Принимать данные в текстовом формате, и уметь компилировать их последовательно в STL либо уметь отображать в 3D сцене.
2) Уметь компилировать много деталей в одном файле, а так же уметь включать разные компоненты как в текстовом виде, так и в виде STL.
3) Уметь строить изометрические проекции, и переводить их в картинки.

stl2gcode конвертор должен
1) Уметь преобразовывать STL файл в G-code для фрезерного станка в 3Д
2) Уметь преобразовывать STL в G-code для 3Д принтера.

path2gcode должен
1) принимать на вход информацию о двумерном перемещении фрезы, и конвертировать его в 2D или 2.5D gcode.

textcad представляет собой интерпретатор вводимого кода, и может сразу же интерпретировать нововведенные объекты.

---

Я решил встроить textcad прямо в мой интерпретатор, поэтому тут будут описываться те типы объектов,
которые будет поддержвать мой интерпретатор

##Графические примитивы textcad

0) Числа. Уже поддержваются. 
0.5) Комментарии. Коментарии начинаются символами // или # в первой позиции строки. Уже реализованы

1) Графическая вершина, или точка. Имеет 3 координаты
	Записываются в обратном синтаксисе
	0 0 0 d1 DOT # d1- имя точки
	1.0 5.4 3.4 d2 DOT

Все координаты точки по умолчанию вводятся в миллиметрах. Если необходимо вводить размер в других единицах, то следует
указать единицы измерения при задании системы координат. По умолчанию система координат прямоугольная,
правая, и единица измерения 1мм.

2) Физическая точка. Физическая точка отличается от графической наличием четвертой координаты, которая может означать
либо цвет, либо плотность, либо радиус физического объема, с центром в графической точке

	1 1 1 0.0002 pt PDOT # PDOT - физическая точка
	
	Фактически физическая точка - это шар. физическую точку можно сделать из графической точки и числа, например

	d1 0.01 pt2 PDOT


3) Единичный вектор. Единичный вектор задает только направление в трехмерном пространстве, поэтому для его задания необходимо только
три координаты, так как начало вектора всегда имеет координату [0,0,0]. 

	1 2 3 v UVEC # это единичный вектора с направлением 1,2,3

3.1) Если нужен простой вектор, то он задается своими проекцийми и словом VEC
	1 2 3 vv VEC

4) Относительный вектор, задается физической точкой, определяется направлением и длиной. Записывается как ([1,2,3,4]), где первые 3 координаты определяют
направление единичного вектора в пространстве, а четвертая координата может определять либо трансляцию вдоль данного вектора, либо поворот вокруг оси 
единичного вектора на определенный угол.
Может использоваться для операций, таких как выталкивание, трансляция, масштабирование, поворот, задания контура, или ломаной линии в пространстве.
	Может образовываться как 4 числа
	3 2 5 4 rr1 RVEC	# 3 числа задают направление единичного вектора, а 4 это длина
	
	3.3 4.1 1.0 d4 DOT  0.4 rr3 RVEC  # определяем геометрическую точку, потом добавляем четвертую координату и делаем вектор
	
	6 7 8 uv3 UVEC 0.5 rr5 RVEC		# создаем единичный вектор, потом добавляем длину.

	1 1.1 2.1 0.4 pd1 PDOT rr6 RVEC # создаем физическую точку, а потом образуем от нее вектор.


3) Прямая линия, или отрезок. Задается как вектор с двумя точками, например ([1,2,3],[4,5,6]). Имеет начало и конец. Может использоваться для задания
отрезка.

	1 2 3 4 5 6 LL LINE	# задает отрезок линии


4) Дуга или окружность, задается аксиальным вектором, например ([2,4,5, 90.0], 10). При этом первые три координаты указывают направление единичного вектора,
и угол поворота, а значение радиуса указывается последним параметром.

	2 3 4 90 10 ar1 ARC # фрагмент окружности.
	Так же дуга может орбазовываться любой другой совокупностью 5 чисел.

	Дугу можно задавать через центр, радиус, номаль и угол поворота.

5) Контур, может быть замкнутым или незамкнутым. Может задаваться точками, отрезками, дугами.
	Может состоять из последовательности отрезков или дуг, например:
	VOID 0 0 0 begin DOT 1 1 0 10 LL LINE  0 0 1 180.0 3 UN ARC begin cont1 CONT

Данный контур начинается из начала координат, из которой выходит линия длиной 10 мм под углом 45 градусов к осям XY, потом эта линия продолжается
закруглением радиусом 3 мм на угол 180 градусов, и потом замыкается на начальной точке.

В данном случае, мы получим контур, похожий на каплю, слегка обрезанную с одной стороны.
	
	Для практических целей скругление углов контура можно сделать после задания самого контура, так как это упрощает его задание.
	например, 
	cont1 0.5 ROND	# закруглить контура радиусом 0.5
	cont1 begin 0.5 ROND # закруглить отдельную вершину с именем begin радиусом 0.5

	Контур при этом меняется, так как теперь вершина begin не лежит на контуре, она получает статус "скругленной"
	А в контур добавляется 3 элемента, это начало дуги скругления, дуга скругления и конец дуги скругления. Все эти элементы
	вставляются после скругленной вершины.


	Можно гладко сшивать окружности в контуре. (Пока не придумал как)

	Контуры можно объединять и состыковывать, пересекать.
	Объеденять можно контуры, которые не пересекаются и имеют противонаправленные вектора нормали. 
	Это необходимо например, для создания конрутов вычитания. Объеденяемые контура не должны пересекаться.

	Так же можно состыковывать незамкнутые контуры, если начало и конец задаются одной и той же точкой.

	Контур не обязательно может быть замкнутый. Незамкнутые контуры используются для генерации поверхностей методом выталкивания либо для
	задания пути выталкивания.
	Замкнутые контуры используются в основном для операции выталкивания физических тел.

	Замыкается контур словом CLOS. То есть задаются все точки, образуется контур, а потом пишется слово CLOS
	Оно устанавливает флаг замкнутости контура.

>Нужно продумать структуру данных контура. То есть должны быть данные о начальных объектах, и потом
все операции, и в конце концов должна быть последовательность сгененрированных точек, то есть скомпилированный контур.

	Контур можно обратить, используем слово REVC - reverse contour

	
5.1) Замкнутый контур создается ключевым словом CONT, а незамкнутый PATH


6) Поверхность задается незамкнутым контуром, который транслировали вдоль некоторого пути.
	
	cont1 cont2 surf1 SURF # генерируем поверхность вдоль некого контура.
	первый контур - это контур который следует вытолкнуть, второй контур - это путь выталкивания.

	При трансляции вдоль контура, задающий контур транслируется вдоль прямой линии с сохранением угла между плоскостью контура,
	а так же при трансляции вдоль дуг так же сохраняет плосопараллельность.

	Выталкивание контура может осуществляться плоскопараллельно или с поворотом, для этого нужно определить
	как контур строится, по умолчанию он плосокпараллельный

	cont1 path2 surf2 SURF TURN # выталкиваемый контур следует пути 2 с поворотом нормали по  окружности если они есть в контуре.
	path1 path2 surf3 SURF 

	Например, у нас есть контур, который образует дугу окружности в 180 градусов.
	{[0,0,5], ([0,1,0, 180.0], 5)}:arc1
	Задаем начальную точку контура, сместившись на 5 мм вверх по оси Z.
	Далее, делаем дугу вдоль оси Y  на 180 градусов радиусом 5 мм.

	Теперь задаем контур для создания поверхности
	{[5,0,0], ([0,0,1, 360.0], 5)}:path1

	Теперь делаем поверхность

	surf(arc1, path1) : surf1

	Данная поверхность не является шаром, она скорее представляет собой цилиндр транслированный вдоль половины дуги.
	Чтобы получить сферическую поверхность нужно включить поворот во время трансляции

	surf(arc1, path1, turn) : surf2

	Замкнутая поверхность может быть обращена в твердое тело. Твердое тело может задаваться как набор поверхностей.

	Так же твердое тело может быть образовано из поверхности, выталкиванием ее перепендикулярно поверхности в одну или обе стороны.

7) Образование твердых тел.

	Твердые тела можно образовывать посредством 

	7.1) Выталкивания замкнутых контуров вдоль заданного пути, определяемого незамкнутым линейным контуром, либо замкнутым криволинейным контуром.
	
	CONT PATH ss SOLI

	solid({},{}) 
	solid({},{},turn)

	Первый аргумент это замкнутый контур, второй контур это путь. Путь может содержать дуги, и при этом можно указать поворот контура вдоль дуги.
	Результирующая поверхность будет описана вокруг всех сгенерированных точек поверхности. 

	7.2) Описанием некого объема пересекающимися поверхностями, причем поверхности не обязательно должны иметь общие ребра. Новые ребра образуются
	в процессе пересечения граней.
	solid(surf1, surf2, surf3, ...)

	Если в результате генерирования не получается сгенерировать замкнутую поверхность, то происходит ошибка генерации.

7.1) Твердые тела могут так же задаваться как набор вершин, объединенных в треугольники, так как это делается в STL файлах.

	При этом, твердое тело имеет нормали, выпуклые наружу.
	Тело может содержать полости, при этом нормаль полостей должна быть направлена внутрь тела.

	
8) Натянутые поверхности. 
	Поверхности можно сгенерировать так же задавая замкнутый контур, операцией stretch.
	stretch({}) : surf1

	При этом, если контур лежит в одной плоскости, то генерируется плоская поверхность.
	Так же можно задать величину выпуклости поверхности, задавая значение от плоскости вдоль вектора нормали поверхности.

	Нпример stretch({}, 5) 
	задаст поверхность, выпуклкую в сторону нормали, задаваемой направлением обхода контура.

	Если контур не лежит в одной плоскости, то все равно может быть задана выпуклость поверхности, относительно среднего положения натянутой мембраны.

9) Параметризация.
	Каждый создаваемый объект описывается в рамках собственной локальной системы координат. Объект имеет синтаксис сходный с си
	например

	Каждый созданный объект является уникальным, но при операцих трансляции или перемещении или копировании создаются образы
	изначальных объектов, параметры которых могут быть изменены, например величина выталкивания, или радиус.

	После операций над телами вся история преобразований сохраняется, а в конце делается окончательная генерация вершин твердого тела,
	и образующих поверхностей. То есть у любого твердого тела можно  выделить любую грань и потом проделать операцию на ней.


	Объект a может иметь список параметров, причем все параметры обязаны иметь значение по умолчанию, например,

	obj b( 5.0:r, 10:d, -180.0:angle)

	Эти параметры могут использоваться внутри тела описания объекта.

	Все описания проводятся в локальной системе координат, однако можно создавать любое другое число систем координат и переключаться
	между ними в процессе построения тела.

	Система координат определяется одним вектором трансляции и 3 углами Эйлера.
	soc(([1,2,3]), al, bet, gam): new_soc1
	
	al bet gam dot1 new_soc SOC 
	Если нужно перейти в новую систему координат, то используется операция перехода NSOC
	После перехода в новую систему координат, все создаваемые объекты будут иметь трансляции и повороты применяемые к координатам объектов.
	Если нужно вернуться к начальной системе координат, то используется OSOC.


10) Интерпретация и сборка.
	Чертеж в textcad представляет собой последовательность определений объектов, причем само описание объекта никак не проявляет его
	на конечном чертеже. Для того, чтобы объект появился, его необходмо задать, например, определяя некоторую систему координат.

	например после определения объекта b необходимо задать его положение на сборочном чертеже через трансляцию и или поворот

	Трансляции и повороты можно задавать векторами или матрицами.

	b(10:r, 20:d, -90:angle, soc1)
	Его так же можно транслировать и повернуть нужным образом, относительно одной из определенных систем координат внутри данного тела.
	система координат выбирается как параметр.

	При задании твердых тел не учитывается их соприкосновение и пересечение.

11) Операции над твердыми телами.
	Обчно твердые тела поредставляют собой комбинацию одного или нескольких простых твердых тел, соединенных булевыми операциями.
	Операции могут быть 

	Объединения, вычитания или пересечения.

	bool(solid1, solid2, intercect) : solid3
	bool(solid3, solid4, subtract) : sloid5
	bool(solid5, solid6, comine): solid7

	Так же от твердого тела можно отсекать некую часть секущей поверхностью. Направление нормали поверхности указывает
	какая часть твердого тела образуется
	Каждый раз, при любой операции образуется новая поверхность, которую можно именовать. 


11.1) Определение примитивов.

	После создания твердых тел каждое из них будет обладать набором граней, ребер, вершин, каждая из которых может 
	быть извлечена и использована в дальнейшем, например можно извлечь определенную грань твердого тела, 
	удовлетворяющую определенным требованиям, например близости к некой точке или просто по номеру


	solid7.fringe[1] : surface1
	У каждой поверхности существует своя система координат, в рамках которой могут быть созданы или помещены любые объекты, в частности
	локальные системы координат или контуры.

	У каждой поверхности может быть от трех и более граней, которые также могут быть извлечены.

	surface1.edge[3] : edge1
	Можно задать любую точку на ребре между двумя вершинами, или в случае кругового ребра - вдоль ребра используя число от 0 до 1.

	edge1.dot[0.5] : middle_point


11.2) Сглаживание повехностей, граней и вершин.

	Как правило при производстве необходимо производить сглаживание вершин, ребер и граней.

	Сглаживание граней может осуществляться посредством задания радиуса или фаски. Или даже заданием переменного радиуса
	в зависимости от смещения.

	chamfer(edge, rad)
	chamfer(edge, {[offset1, rad1], [offset2, rad2]})
	Если не задаются крайние точки, то радиус принимается постоянным rad1 от нуля до offset1. То же справедливо для другого угла.

	После применения сглаживания появляются новые грани, и ребра, которые так же могут участвовать в других операциях.

	Для сглаживания трех и более поверхностей применяется команда 

	smooth(surface1, surface2, surface3, param) : surf4
	результатом будет сложная поверхность образованная ребрами исходных граней.
	Параметр может опредеять степерь выпуклости или вогнутости поверхности.

11.2) Операции симметрии, отражение, копирование, перенос.
	mirror, copy, move.

12) Задание цвета и материала или текстуры поверхности.
	Любой объект может иметь некоторый предпочтительный цвет или прозрачность, которую можно задать 4 вектором
	color ([0.5,0.5,0, 1.0])
	Можно так же задать материал, применяемый к той или иной грани, как параметр material.

	интерпретатор будет определять имя материала как объект и будет пытаться использовать его для рэндеринга объекта.

13) Интерполяция тел, заданных сетками. Мне для параметризации физических твердых тел часто будет необходимо получить 
упрощенное описание объектов, представленных в виде STL файлов, например, чтобы описать модель посредством примитивов, трансляций и
вращений.

То есть этот процесс должен начинаться с прикладыванием плоскостей со всех сторон к исследуемому объекту, потом попыткой
описывать поверхности конусами, сферами, и другими объектами, пытаясь минимизировать отклонения от поверхности, или минимизировать
объем твердого тела.


	------------------------


##Примеры

#Cube

a dubl var 
0 0 0 begin DOT
a 0 0 a1 DOT
a a 0 a2 DOT
0 a 0 a3 DOT
base CONT

begin # beginning of the path,
0 0 a h1 DOT # end of the path
ch PATH 	#cube height
cube SOLI

при задании графических объектов они автоматически становятся сложными типами, и обращение к полям сложных типов
производится по именованым смещениям.

чтобы создать переменную типа cube потупаем как в случае с переменной,

	cube1 cube VAR

Если же использовать просто имя типа без задания имени переменной, то операции будут производится над типами.


Мы задали куб, который можно теперь транслировать, создавать копии его и перемещать в пространстве.
При копировании, все ссылки на переменные так же копируются и их можно изменять
Чтобы добраться до значений переменных в структуре хранятся смещения на параметры объекта, поэтому можно либо
указывать смещение, либо записывать имя переменной, указанной при обращении, только наверное нужно это делать
с каким нибудь знаком типа "/". 
> тут надо подумать, как связывать вложенные в структуру имена переменных, со смещениями при копировании структур.

Чтобы создать куб нужно задать его положение в некой системе координат

3 4 5 v1 VEC
0 0 0 soc1 SOC # создаем систему координат с вектором 3 4 5 и нулевыми поворотами относительно осей глобальной системы координат

1 a eq cube soc1 PLAC # Расположить с заданными размерами и трансляцией в модели.


--------------------
#stl2gcode

Генератор G-code из данного STL файла или модели должен делать проход заданным инструментом.

Вообще говоря, его тоже можно встроить в интерпретатор. Для этого нужно еще создать типы инструмента типа 
фрезы, сверла, и тд. с указанием геометрии. 

Техническое задание:
1) Программа должна читать STL файл из командной строки.
2) В командной строке задается так же положение начала координат и угол поворота STL файла.
3) Задается карман (объем) для выборки в виде параллелепипеда или другой призмы.
	Считается, что объем заполнен материалом.
4) Задается файл с геометрией фрезы и параметрами подачи, клиренсом шпинделя.
5) Задаются способ фрезерования, для грубой и для точной проходки.
6) Смена тула если необходимо.
7) Выходной файл должен быть в формате Mach3 и Linuxcnc

После генерации пути выходной файл будет представлять собой текст, который можно будет сохранить


##Алгоритм
--------

	1)Начнем с загрузки STL файла и нормализации вершин. Определяем только те вершины, которые находятся в milling объеме,
	и прилегающие к ним. 

	2) Определяем поверхность, объем выборки с учетом клиренса фрезы и шпинделя.

	3) Определяем способ и траекторию грубой выборки, то есть предполагается, что полость заполнена материалом.

	4) Определяет способ и траекторию тонкой выборки, в отсутствие материала.

	5) Сохранение в файл.


	intersect(soild1, soild2 ) : solid3

	Для начала будем считать, что solid2 это обычный прямоугольный параллелепипед.
	То есть определяем 
	xmin, xmax, ymin, ymax, zmin, zmax.

	Потом в цикле перебираем все вершины, принадлежащие solid1 на предмет попадания в параллелепипед.

	Составляем список вершин, находящихся в параллелепипеде. 
	Затем составляем список соседей этих вершин, находящихся за пределами параллелепипеда.
	И находим точку пересечения отрезка с повехностью параллелепипеда.

	Добавляем эту точку в список вершин параллелепипеда.
	На этом нахождение пересечения закончено.

	generate_path()

	Генерация пути выборки, используя геометрию фрезы, способ выборки и точность.
	Геометрия фрезы задается длиной фрезы, формой конца, геометрией патрона шпинделя (для криренса, если надо).

	Надо определить точку входа и направление обхода модели, максимальную глубину прохода, максимальный заход, частоту вращения
	шпинделя.


	Операция генерации кода будет выглядеть примерно так
	1) задаем форму детали
	2) задаем форму стока
	3) Определяем пересечение
	4) задаем тул
	5) команда MILL
	6) Если надо точить команда LATH
	7) на выходе получаем g-code

	



   









