[29.05.2017]

#README

Генерация G-code из STL модели для 3D ферзерования.

Необходимо строить задачу иерархически, например на самом верхнем уровне будет
Работа, или цикл
Цикл - это последовательность операций над заготовкой, которую следует выполнить чтобы получить требуемую обработку.

* Цикл состоит из проходов, пауз или смен оборудования, и установок координат.

--

	0) Установка начала координат, это скрипт, который выполняется при установленном пробнике и задает 
начала отсчета для следующей операции.

	1) Проход - это последовательность движений фрезы одного типа без перестановки.

	2) Пауза или смена оборудования - это фрагмент кода, при котором определяется оператором следующее действие.


Для генерации прохода необходимо задать 
	
	1) Модель, или 3D файл, в формате STL.
	2) Ориентацию модели в пространстве, по отношению к системе координат станка.
	3) Инструмент для прохода, его геометрию.

	4) Карман выборки. Это призматический объем, который определяет место выборки, в предельном случае совпадает 
	с геометрией заготовки.

	5) Параметры фрезерования


---

[30.05.2017]

	Видимо придется делать свой кад с нуля, так как опенскад меня не очень устраивает.

Техническое задание:
textcad должен
1) Принимать данные в текстовом формате, и уметь компилировать их последовательно в STL либо уметь отображать в 3D сцене.
2) Уметь компилировать много деталей в одном файле, а так же уметь включать разные компоненты как в текстовом виде, так и в виде STL.
3) Уметь строить изометрические проекции, и переводить их в картинки.

stl2gcode конвертор должен
1) Уметь преобразовывать STL файл в G-code для фрезерного станка в 3Д
2) Уметь преобразовывать STL в G-code для 3Д принтера.

path2gcode должен
1) принимать на вход информацию о двумерном перемещении фрезы, и конвертировать его в 2D или 2.5D gcode.

textcad представляет собой интерпретатор вводимого кода, и может сразу же интерпретировать нововведенные объекты.

---

##Графические примитивы textcad

0) Числа. Все числа считаются константами, им можно задавать имя: 5:r5
Имена case sensitive.

0.5) Комментарии. Коментарии начинаются символами // или # в первой позиции строки.

1) Графическая вершина, или точка. Имеет 3 координаты, которые записываются в [] скобках.
Например [1.0, 5.4, 3.4]. Имеют значение смещения вдоль правосторонней локальной системой координат.
Можно привоить уникальное имя точке, например [0,0,0]:origin

Все координаты точки по умолчанию вводятся в миллиметрах. Если необходимо вводить размер в других единицах, то следует
указать единицы измерения при задании системы координат. По умолчанию система координат прямоугольная,
правая, и единица измерения 1мм.

2) Физическая точка. Физическая точка отличается от графической наличием четвертой координаты, которая может означать
либо цвет, либо плотность, либо радиус физического объема, с центром в графической точке
[1, 1, 1, 0.0002]
Фактически физическая точка - это шар.

3) Единичный вектор. Единичный вектор задает только направление в трехмерном пространстве, поэтому для его задания необходимо только
три координаты, так как начало вектора всегда имеет координату [0,0,0]. Единичный вектор задается как (1,2,3) или как ([1,2,3]).
Возможно использовать имя точки, если оно уже было определено. Например (dir1).

4) Относительный вектор, задается физической точкой, определяется направлением и длиной. Записывается как ([1,2,3,4]), где первые 3 координаты определяют
направление единичного вектора в пространстве, а четвертая координата может определять либо трансляцию вдоль данного вектора, либо поворот вокруг оси 
единичного вектора на определенный угол.
Может использоваться для операций, таких как выталкивание, трансляция, масштабирование, поворот, задания контура, или ломаной линии в пространстве.


3) Прямая линия, или отрезок. Задается как вектор с двумя точками, например ([1,2,3],[4,5,6]). Имеет начало и конец. Может использоваться для задания
отрезка.

4) Дуга или окружность, задается аксиальным вектором, например ([2,4,5, 90.0], 10). При этом первые три координаты указывают направление единичного вектора,
и угол поворота, а значение радиуса указывается последним параметром.

5) Замкнутый контур, или ломаная линия. Может состоять из последовательности отрезков или дуг, например:
	{[0,0,0]:begin, ([1,1,0, 10]), ([0,0,1, 180.0], 3), (begin)}:cont1
Данный контур начинается из начала координат, из которой выходит линия длиной 10 мм под углом 45 градусов к осям XY, потом эта линия продолжается
закруглением радиусом 3 мм на угол 180 градусов, и потом замыкается на начальной точке.

В данном случае, мы получим контур, похожий на каплю, слегка обрезанную с одной стороны.
Для того, чтобы получить гладкий переход окружности в прямую линию, нужно указать переменный угол дуги (*)

	{[0,0,0]:begin, ([1,1,0, 10]), ([0,0,1, *], 3), (begin)}:cont1

Надо заметить, что единичный вектор дуги направлен вдоль оси Z, и вращение вдоль этой оси происходит против часовой стрелки.
При задании переменного угла если есть несколько вариантов поворота - то выбирается минимальный угол поворота по умолчанию.
Если тебуется бОльший угол поворота, то вместо (*) используется (**)

Так же можно гладко сшивать окружности в контуре.

Контур не обязательно может быть замкнутый. Незамкнутые контуры используются для генерации поверхностей методом выталкивания либо для
задания пути выталкивания.
Замкнутые контуры используются в основном для операции выталкивания физических тел.

6) Поверхность задается незамкнутым контуром, который транслировали вдоль некоторого пути.
	таким образом, поверхность обозначается как 
		surf({},{})
	где первый контур - это контур который следует вытолкнуть, второй контур - это путь выталкивания.

	При трансляции вдоль контура, задающий контур транслируется вдоль прямой линии с сохранением угла между плоскостью контура,
	а так же при трансляции вдоль дуг так же сохраняет плосопараллельность.

	Если требуется, чтобы при трансляции вдоль дуги происходил поворот контура, для этого нужно указать еще один аргумент
		surf({},{}, turn)

	Например, у нас есть контур, который образует дугу окружности в 180 градусов.
	{[0,0,5], ([0,1,0, 180.0], 5)}:arc1
	Задаем начальную точку контура, сместившись на 5 мм вверх по оси Z.
	Далее, делаем дугу вдоль оси Y  на 180 градусов радиусом 5 мм.

	Теперь задаем контур для создания поверхности
	{[5,0,0], ([0,0,1, 360.0], 5)}:path1

	Теперь делаем поверхность

	surf(arc1, path1) : surf1

	Данная поверхность не является шаром, она скорее представляет собой цилиндр транслированный вдоль половины дуги.
	Чтобы получить сферическую поверхность нужно включить поворот во время трансляции

	surf(arc1, path1, turn) : surf2

	Замкнутая поверхность может быть обращена в твердое тело. Твердое тело может задаваться как набор поверхностей.

	Так же твердое тело может быть образовано из поверхности, выталкиванием ее перепендикулярно поверхности в одну или обе стороны.

7) Образование твердых тел.
	Твердые тела можно образовывать посредством 

	7.1) Выталкивания замкнутых контуров вдоль заданного пути, определяемого незамкнутым линейным контуром, либо замкнутым криволинейным контуром.
	
	solid({},{}) 
	solid({},{},turn)

	Первый аргумент это замкнутый контур, второй контур это путь. Путь может содержать дуги, и при этом можно указать поворот контура вдоль дуги.
	Результирующая поверхность будет описана вокруг всех сгенерированных точек поверхности. 

	7.2) Описанием некого объема пересекающимися поверхностями, причем поверхности не обязательно должны иметь общие ребра. Новые ребра образуются
	в процессе пересечения граней.
	solid(surf1, surf2, surf3, ...)

	Если в результате генерирования не получается сгенерировать замкнутую поверхность, то происходит ошибка генерации.
	

8) Натянутые поверхности. 
	Поверхности можно сгенерировать так же задавая замкнутый контур, операцией stretch.
	stretch({}) : surf1

	При этом, если контур лежит в одной плоскости, то генерируется плоская поверхность.
	Так же можно задать величину выпуклости поверхности, задавая значение от плоскости вдоль вектора нормали поверхности.

	Нпример stretch({}, 5) 
	задаст поверхность, выпуклкую в сторону нормали, задаваемой направлением обхода контура.

	Если контур не лежит в одной плоскости, то все равно может быть задана выпуклость поверхности, относительно среднего положения натянутой мембраны.

9) Параметризация.
	Каждый создаваемый объект описывается в рамках собственной локальной системы координат. Объект имеет синтаксис сходный с си
	например

	obj a(...)
	{
		...
	}

	Объект a может иметь список параметров, причем все параметры обязаны иметь значение по умолчанию, например,

	obj b( 5.0:r, 10:d, -180.0:angle)

	Эти параметры могут использоваться внутри тела описания объекта.

	Все описания проводятся в локальной системе координат, однако можно создавать любое другое число систем координат и переключаться
	между ними в процессе построения тела.

	Система координат определяется одним вектором трансляции и 3 углами Эйлера.
	soc(([1,2,3]), al, bet, gam): new_soc1

	Если какой-то объект создается в другой системе координат, то следует указать, что объекты будут содержаться в ней

	new_soc1: {...}
	Все объекты, созданные в локальной системе координат будут в ней отрисовываться.
	По сути дела, задание новой системы ко



10) Интерпретация и сборка.
	Чертеж в textcad представляет собой последовательность определений объектов, причем само описание объекта никак не проявляет его
	на конечном чертеже. Для того, чтобы объект появился, его необходмо задать, например, определяя некоторую систему координат.

	например после определения объекта b необходимо задать его положение на сборочном чертеже, например

	b(10:r, 20:d, -90:angle, soc1)
	Его так же можно транслировать и повернуть нужным образом, относительно одной из определенных систем координат внутри данного тела.
	система координат выбирается как параметр.

	При задании твердых тел не учитывается их соприкосновение и пересечение.

11) Операции над твердыми телами.
	Обчно твердые тела поредставляют собой комбинацию одного или нескольких простых твердых тел, соединенных булевыми операциями.
	Операции могут быть 

	Объединения, вычитания или пересечения.

	bool(solid1, solid2, intercect) : solid3
	bool(solid3, solid4, subtract) : sloid5
	bool(solid5, solid6, comine): solid7

11.1) Определение примитивов.

	После создания твердых тел каждое из них будет обладать набором граней, ребер, вершит, каждая из которых может быть извлечена и использована
	в дальнейшем,
	например можно извлечь определенную грань твердого тела, удовлетворяющую определенным требованиям, например близости к некой
	точке или просто по номеру

	solid7.fringe[1] : surface1
	У каждой поверхности существует своя система координат, в рамках которой могут быть созданы или помещены любые объекты, в частности
	локальные системы координат или контуры.

	У каждой поверхности может быть от трех и более граней, которые также могут быть извлечены.

	surface1.edge[3] : edge1
	Можно задать любую точку на ребре между двумя вершинами, или в случае кругового ребра - вдоль ребра используя число от 0 до 1.

	edge1.dot[0.5] : middle_point


11.2) Сглаживание повехностей, граней и вершин.

	Как правило при производстве необходимо производить сглаживание вершин, ребер и граней.

	Сглаживание граней может осуществляться посредством задания радиуса или фаски. Или даже заданием переменного радиуса
	в зависимости от смещения.

	chamfer(edge, rad)
	chamfer(edge, {[offset1, rad1], [offset2, rad2]})
	Если не задаются крайние точки, то радиус принимается постоянным rad1 от нуля до offset1. То же справедливо для другого угла.

	После применения сглаживания появляются новые грани, и ребра, которые так же могут участвовать в других операциях.

	Для сглаживания трех и более поверхностей применяется команда 

	smooth(surface1, surface2, surface3, param) : surf4
	результатом будет сложная поверхность образованная ребрами исходных граней.
	Параметр может опредеять степерь выпуклости или вогнутости поверхности.

11.2) Операции симметрии, отражение, копирование, перенос.
	mirror, copy, move.

12) Задание цвета и материала или текстуры поверхности.
	Любой объект может иметь некоторый предпочтительный цвет или прозрачность, которую можно задать 4 вектором
	color ([0.5,0.5,0, 1.0])
	Можно так же задать материал, применяемый к той или иной грани, как параметр material.

	интерпретатор будет определять имя материала как объект и будет пытаться использовать его для рэндеринга объекта.



	------------------------


##Примеры

#Cube
obj cube( 1.0 : a )
{
	color(red);
	{[0,0,0]:begin, [a,0,0], [a,a,0], [0, a, 0], begin }:base;
	solid(base, {begin, [0,0,a]}): cube;
}
cube(1);
#anther cube at a distance and turned
soc([10,20,30], 30, 40, 50) {
	cube(2);
}



--------------------
#stl2gcode

Более насущным для меня является генератор G-code из данного STL файла, поэтому вероятно следует начать с него.

Техническое задание:
1) Программа должна читать STL файл из командной строки.
2) В командной строке задается так же положение начала координат и угол поворота STL файла.
3) Задается карман (объем) для выборки в виде параллелепипеда или другой призмы.
	Считается, что объем заполнен материалом.
4) Задается файл с геометрией фрезы и параметрами подачи, клиренсом шпинделя.
5) Задаются способ фрезерования, для грубой и для точной проходки.
6) Смена тула если необходимо.
7) Выходной файл должен быть в формате Mach3 и Linuxcnc


##Алгоритм
--------

	1)Начнем с загрузки STL файла и нормализации вершин. Определяем только те вершины, которые находятся в milling объеме,
	и прилегающие к ним. 

	2) Определяем поверхность, объем выборки с учетом клиренса фрезы и шпинделя.

	3) Определяем способ и траекторию грубой выборки, то есть предполагается, что полость заполнена материалом.

	4) Определяет способ и траекторию тонкой выборки, в отсутствие материала.

	5) Сохранение в файл.


	intersect(soild1, soild2 ) : solid3

	Для начала будем считать, что solid2 это обычный прямоугольный параллелепипед.
	То есть определяем 
	xmin, xmax, ymin, ymax, zmin, zmax.

	Потом в цикле перебираем все вершины, принадлежащие solid1 на предмет попадания в параллелепипед.

	Составляем список вершин, находящихся в параллелепипеде. 
	Затем составляем список соседей этих вершин, находящихся за пределами параллелепипеда.
	И находим точку пересечения отрезка с повехностью параллелепипеда.

	Добавляем эту точку в список вершин параллелепипеда.
	На этом нахожнение пересечения закончено.

	generate_path()

	Генерация пути выборки, используя геометрию фрезы, способ выборки и точность.
	Геометрия фрезы задается длиной фрезы, формой конца, геометрией патрона шпинделя (для криренса, если надо).

	Надо определить точку входа и направление обхода модели, максимальную глубину прохода, максимальный заход, частоту вращения
	шпинделя.




   









